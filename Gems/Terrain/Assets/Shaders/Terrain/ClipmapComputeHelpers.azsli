/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#define CLIPMAP_SIZE 1024
#define CLIPMAP_STACK_SIZE 4

// Clipmap levels
// --------|--------------|-------- level 0 stack 0
//   ------|--------------|------   level 1 stack 1
//     ----|--------------|----     level 2 stack 2
//       --|--------------|--       level 3 stack 3
//         |--------------|         level 4 pyramid mip 0 (covers the whole map)
//         |  ----------  |         level 5 pyramid mip 1
//         |    ------    |         level 6 pyramid mip 2
//         |      --      |         level 7 pyramid mip 3

float2 GetPreviousClipmapCenter(uint clipmapLevel)
{
    return PassSrg::m_clipmapData.m_clipmapCenters[clipmapLevel].xy;
}

float2 GetCurrentClipmapCenter(uint clipmapLevel)
{
    return PassSrg::m_clipmapData.m_clipmapCenters[clipmapLevel].zw;
}

float2 GetWorldPosition(float2 clipmapCenter, uint2 pixelPosition, uint clipmapLevel)
{
    float2 normalizedPixelPosition = float2((float)pixelPosition.x, (float)pixelPosition.y) / ((float)CLIPMAP_SIZE);
    
    float2 distance = normalizedPixelPosition - clipmapCenter;

    // Toroidal addressing:
    // If distance is out of the normalized range (-0.5, 0.5), meaning we need to start from the other side.
    // The logic is equivalent to a modulation. Using step function for accelation.
    distance.x -= 1.0 * step(0.5, distance.x);
    distance.x += 1.0 * step(distance.x, -0.5);
    distance.y -= 1.0 * step(0.5, distance.y);
    distance.y += 1.0 * step(distance.y, -0.5);

    float clipmapScale = 1.0 / float(1 << (CLIPMAP_STACK_SIZE - clipmapLevel));
    float2 maxRenderSize = PassSrg::m_clipmapData.m_maxRenderSize.xy;
    float2 viewRelativePosition = distance * (maxRenderSize * clipmapScale);
    return PassSrg::m_clipmapData.m_currentViewPosition.xy + viewRelativePosition;
}

float2 GetPreviousWorldPosition(uint2 pixelPosition, uint clipmapLevel)
{
    float2 previousClipmapCenter = GetPreviousClipmapCenter(clipmapLevel);
    return GetWorldPosition(previousClipmapCenter, pixelPosition, clipmapLevel);
}

float2 GetCurrentWorldPosition(uint2 pixelPosition, uint clipmapLevel)
{
    float2 currentClipmapCenter = GetCurrentClipmapCenter(clipmapLevel);
    return GetWorldPosition(currentClipmapCenter, pixelPosition, clipmapLevel);
}

bool NeedsUpdate(uint2 pixelPosition, uint clipmapLevel)
{
    float2 worldPosition = GetPreviousWorldPosition(pixelPosition, clipmapLevel);
    
    float2 currentViewPosition = PassSrg::m_clipmapData.m_currentViewPosition.xy;
    float2 distance = abs(worldPosition - currentViewPosition);
    
    float clipmapScale = 1.0 / float(1 << (CLIPMAP_STACK_SIZE - clipmapLevel));
    float2 maxRenderSize = PassSrg::m_clipmapData.maxRenderSize.xy;
    
    float2 clipmapMaxDistance = maxRenderSize * (clipmapScale / 2.0);
    
    // If the previous world position of this texel is within the current
    // range of the clipmap, then we can claim this texel is still valid
    // and it represents the same world position as the clipmap in the previous
    // frame.
    return any(clipmapMaxDistance < distance);
}

// Clipmap generation works like a pixel shader, but derivative functions are
// not available in compute shaders.
float2 ddxPosition(uint2 pixelPosition, uint clipmapLevel)
{
    uint2 pixelPositionNextX = uint2(pixelPosition.x + 1, pixelPosition.y);
    return GetCurrentWorldPosition(pixelPositionNextX, clipmapLevel) - GetCurrentWorldPosition(pixelPosition, clipmapLevel);
}

float2 ddyPosition(uint2 pixelPosition, uint clipmapLevel)
{
    uint2 pixelPositionNextY = uint2(pixelPosition.x, pixelPosition.y + 1);
    return GetCurrentWorldPosition(pixelPositionNextY, clipmapLevel) - GetCurrentWorldPosition(pixelPosition, clipmapLevel);
}
