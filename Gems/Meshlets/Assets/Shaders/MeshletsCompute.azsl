#pragma once

#include <Atom/Features/SrgSemantics.azsli>

//------------------------------------------------------------------------------
ShaderResourceGroup PassSrg : SRG_PerPass_WithFallback
{   // [Adi] No needto use StructuredBuffer - change to buffer
    RWStructuredBuffer<int>     m_MeshletsSharedBuffer;
}

//------------------------------------------------------------------------------
//! The following meshlet descriptor structure must reflect the structure as 
//! appeared in MeshletsData.h 
struct MeshletDescriptor
{
    //! Offset into the indirect indices array representing the global index of
    //! all the meshlet vertices.
    //! The Indirect vertices array is built as follows:
    //!     std::vector<uint32_t> indirectIndices;
    //!     indirectIndices = { { meshlet 1 vertex indices }, { meshlet 2 }, .. { meshlet n} }
    uint vertexOffset;      // In uint32_t steps

    //! Offset into the global meshlets triangleIndices array represented as:
    //!     std::vector<uint8_t> triangleIndices;
    //!     triangleIndices = { {meshlet 1 local indices group}, ... { meshlet n} }
    //! The local indices are an 8 bits index that can represent up to 256 entries.
    uint triangleOffset;    // In bytes from the start of the array

    //! Finding a vertex within the meshlet is done like that:
    //!     triangleOffset = currentMeshlet.triangleOffset + meshletTrIndex * 3;
    //!     localIndex_i = meshletTriangles[triangleOffset + i];    // i = triangle vertex index 0..2
    //!     vertexIndex_i =  indirectIndices[currentMeshlet.vertexOffset + localIndex_i];

    //! Amount of vertices and triangle for the mesh - based on this the arrays
    //! indirectIndices and triangleIndices are created per meshlet.
    uint vertexCount;
    uint triangleCount;
};

//------------------------------------------------------------------------------
ShaderResourceGroup MeshletsDataSrg : SRG_PerObject
{
    // Shared buffer offset in uint to be used when using the shared buffer when 
    // addressing the properties 
    uint m_indicesOffset;   
    uint m_texCoordsOffset;
    uint2 padding;

    // For the next array review the structuee 'MeshletDescriptor'.
    // The array holds the offsets and amount of vertices and triangles per 
    // meshlet.
//    Buffer<uint4>  m_meshletsDescriptors;
    StructuredBuffer<MeshletDescriptor> m_meshletsDescriptors;

    // The following arrya consistes of sub arrays of triangles - one per meshlet.
    // Each uint (32 bits) represents 3 x 8 bits indices into the meshlet indices 
    // lookup array (the top byte is unused).
    Buffer<uint>    m_meshletsTriangles;    

    // Array of sub-tables, each one represents lookup table for a meshlet that 
    // maps between a meshlet local vertex index and its global index in the mesh.

    Buffer<uint>    m_meshletsIndicesLookup;

    // ---------------------------------------------
    // The following two buffers are in fact buffer views into the shared buffer 
    // so that the GPU memory can be synchronized via the pass system using only 
    // a single buffer and barier between passes.
    // ---------------------------------------------
    // Index buffer of the mesh comprised of meshlets
    // Meshlets Compute threads will write the calculated indices per meshlet and 
    // store it in the array if the meshlets are not culled.
    RWBuffer<uint>  m_indices;

    // Mesh texture coordinates - will be used for debug purposes to color meshlets
    RWBuffer<float2> m_uvs;

    //--------------------------------------------------------------------------
    uint GetVertexIndex(uint index)
    {
        return PassSrg::m_MeshletsSharedBuffer[m_indicesOffset + index];
    }

    void SetVertexIndex(uint index, uint vertexIndex )
    {
        PassSrg::m_MeshletsSharedBuffer[m_indicesOffset + index] = vertexIndex;
    }

    void SetTriangleIndices(uint index, uint3 triIndices)
    {
        uint indexOffset = m_indicesOffset + index;
        PassSrg::m_MeshletsSharedBuffer[indexOffset] = triIndices.x;
        PassSrg::m_MeshletsSharedBuffer[indexOffset+1] = triIndices.y;
        PassSrg::m_MeshletsSharedBuffer[indexOffset+2] = triIndices.z;
    }

    void SetUVs(uint index, float2 texCoords)
    {
        // index multiplied by 2 since we have two coordinates 
        uint texCoordIndex = m_texCoordsOffset + (index << 1);
        PassSrg::m_MeshletsSharedBuffer[texCoordIndex] = asint(texCoords.x);    
        PassSrg::m_MeshletsSharedBuffer[texCoordIndex+1] = asint(texCoords.y);    
    }
};

//------------------------------------------------------------------------------
// Given the local meshlet' triangle index and the meshlet, the function calculates
// the global triangle's vertex indices and returns them along with the global 
// triangle offset.
//------------------------------------------------------------------------------
uint4 GetGlobalVertexIndicesAndTriOffset(MeshletDescriptor meshlet, uint localTriangleIdx)
{
    uint globalTriangleIndex = meshlet.triangleOffset + localTriangleIdx;
    uint encodedTri = MeshletsDataSrg::m_meshletsTriangles[globalTriangleIndex];
    uint3 localIndices = uint3(
        (encodedTri) & 0xff,
        (encodedTri >> 8) & 0xff,
        (encodedTri >> 16) & 0xff
    );

    uint3 globalIndirection = meshlet.vertexOffset + localIndices;
    uint4 globalVertexIndicesAndTriOffset = uint4(
        MeshletsDataSrg::m_meshletsIndicesLookup[globalIndirection.x],
        MeshletsDataSrg::m_meshletsIndicesLookup[globalIndirection.y],
        MeshletsDataSrg::m_meshletsIndicesLookup[globalIndirection.z],
        globalTriangleIndex * 3
    );

    return globalVertexIndicesAndTriOffset;
}

/*
void MeshletsModel::debugMarkMeshletsUVs(GeneratorMesh& mesh)	// Results will alter the mesh 
{
    for (uint32_t meshletId = 0; meshletId < m_meshletsData.Descriptors.size(); ++meshletId)
    {
        meshopt_Meshlet& meshlet = m_meshletsData.Descriptors[meshletId];
        float tx = (meshletId % 3) * 0.5f;
        float ty = ((meshletId / 3) % 3) * 0.5f;
        for (uint32_t localTriangleIdx = 0 ; localTriangleIdx < meshlet.triangle_count; ++localTriangleIdx)
        {
            uint32_t globalTriangleIndex = meshlet.triangle_offset + localTriangleIdx;
            uint32_t encodedTri = m_meshletsData.EncodedTriangles[globalTriangleIndex];
            // Next bring decode the uint32_t and separate into three elements.
            uint8_t vtxIndirectIndex[3] = {
                (encodedTri >> 0) & 0xff,
                (encodedTri >> 8) & 0xff,
                (encodedTri >> 16) & 0xff
            }; 

            for (uint32_t vtx = 0; vtx < 3; ++vtx)
            {
                uint32_t globalIndirection = meshlet.vertex_offset + vtxIndirectIndex[vtx];
                uint32_t vtxIndex = m_meshletsData.IndicesIndirection[globalIndirection];

                mesh.vertices[vtxIndex].tx = tx;
                mesh.vertices[vtxIndex].ty = ty;
            }
        } 
    }
}
*/


//------------------------------------------------------------------------------
//! The group's threads count should match either Meshlets::maxVerticesPerMeshlet
//! or Meshlets::maxTrianglesPerMeshlet depending on our algorithm for minimizing 
//! amount of work per thread and achieving max parallelizm.
//------------------------------------------------------------------------------
#define THREADS_COUNT 128
//------------------------------------------------------------------------------
[numthreads(THREADS_COUNT, 1, 1)]
void ComputeMeshletsIndexBuffer(
    uint groupIndex : SV_GroupIndex,
    uint3 groupId : SV_GroupID,
    uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint meshletId = groupId.x;
    MeshletDescriptor meshlet = MeshletsDataSrg::m_meshletsDescriptors[meshletId];

    float2 debugUVs = float2( (meshletId % 3), ((meshletId / 3) % 3) ) * 0.5;

#ifdef _DEBUG_TEST_CONTENT_
    ///////////////////////// Start - Test Debug Only ////////////////////////////
    // Simple ark the first 4 entries of each meshlet 
    if ((groupIndex < meshlet.triangleCount) && (groupIndex < 4))
    {
        uint4 vtxGlobalVerticesAndTriOffset = GetGlobalVertexIndicesAndTriOffset(meshlet, groupIndex);

        // Both method work!!!
        if (groupIndex < 2)
        {
            // Sub-Buffers address
            // Tested OK
            MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w] = 555;
            MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w + 1] = meshletId;
            MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w + 2] = groupIndex;

            // Tested OK - notice that writing to address is writing float2! (not a single element)
            MeshletsDataSrg::m_uvs[vtxGlobalVerticesAndTriOffset.w] = 555;
            MeshletsDataSrg::m_uvs[vtxGlobalVerticesAndTriOffset.w + 1] = groupIndex;

            // This is the indirection in into the vertex pointed by the Index Buffer but since it
            // can be located anywhere, we'll postpone this
//            MeshletsDataSrg::m_uvs[2 * MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w]] = 555;
//            MeshletsDataSrg::m_uvs[2 * MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w + 1]] = meshletId;
//            MeshletsDataSrg::m_uvs[2 * MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w + 2]] = debugUVs;
        }
        else
        {
            // Shared Buffer using offsets
            uint3 testIndex = uint3(22,meshletId,groupIndex);

            // Tested OK
            MeshletsDataSrg::SetTriangleIndices(vtxGlobalVerticesAndTriOffset.w, testIndex);

            // Tested OK
            MeshletsDataSrg::SetUVs(vtxGlobalVerticesAndTriOffset.w, groupIndex);
            MeshletsDataSrg::SetUVs(vtxGlobalVerticesAndTriOffset.w + 1, groupIndex);
            MeshletsDataSrg::SetUVs(vtxGlobalVerticesAndTriOffset.w + 2, groupIndex);
        }
        return;
    }
    ///////////////////////// End - Test Debug Only ////////////////////////////
#endif

    // Leave the first 10 indices and vertices data intact
    if (groupIndex < 2)
    {
        return;
    }

    if (groupIndex < meshlet.triangleCount)
    {   // groupIndex is used here as the index of the trianlge we process
        uint4 vtxGlobalVerticesAndTriOffset = GetGlobalVertexIndicesAndTriOffset(meshlet, groupIndex);

//#define _USE_SHARED_BUFFER_OFFSET_
#ifdef _USE_SHARED_BUFFER_OFFSET_
        //// Setting the various properties via usage of the shared buffer with offsets
        // Construct the triangles using the meshlets data
        MeshletsDataSrg::SetTriangleIndices(vtxGlobalVerticesAndTriOffset.w, vtxGlobalVerticesAndTriOffset.xyz);

        // Mark the triangles based on the meshlets Id.
        MeshletsDataSrg::SetUVs(vtxGlobalVerticesAndTriOffset.x, debugUVs);
        MeshletsDataSrg::SetUVs(vtxGlobalVerticesAndTriOffset.y, debugUVs);
        MeshletsDataSrg::SetUVs(vtxGlobalVerticesAndTriOffset.z, debugUVs);
#else
        //// Setting the properties directly through the buffer views that represent areas 
        //// in the memory of the shared buffer. 
        // The following will not work since RW buffers are used indirectly and although they are 
        // associated with the PerPass shared buffers, the RHI validation will fail it becuase of 
        // missing frame attachment
        // Set the global mesh index buffer for this meshlet triangle
        MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w] = vtxGlobalVerticesAndTriOffset.x;
        MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w + 1] = vtxGlobalVerticesAndTriOffset.y;
        MeshletsDataSrg::m_indices[vtxGlobalVerticesAndTriOffset.w + 2] = vtxGlobalVerticesAndTriOffset.z;

        // Set the vertices UV according to the meshlet Id as a debug indication
        MeshletsDataSrg::m_uvs[vtxGlobalVerticesAndTriOffset.x] = debugUVs;
        MeshletsDataSrg::m_uvs[vtxGlobalVerticesAndTriOffset.y] = debugUVs;        
        MeshletsDataSrg::m_uvs[vtxGlobalVerticesAndTriOffset.z] = debugUVs;
#endif
    }

//    GroupMemoryBarrierWithGroupSync();
}
