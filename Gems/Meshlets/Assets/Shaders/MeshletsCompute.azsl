#pragma once

#include <Atom/Features/SrgSemantics.azsli>


//------------------------------------------------------------------------------
//! The following meshlet descriptor structure must reflect the structure as 
//! appeared in MeshletsData.h 
struct MeshletDescriptor
{
    //! Offset into the indirect indices array representing the global index of
    //! all the meshlet vertices.
    //! The Indirect vertices array is built as follows:
    //!     std::vector<uint32_t> indirectIndices;
    //!     indirectIndices = { { meshlet 1 vertex indices }, { meshlet 2 }, .. { meshlet n} }
    uint vertexOffset;      // In uint32_t steps

    //! Offset into the global meshlets triangleIndices array represented as:
    //!     std::vector<uint8_t> triangleIndices;
    //!     triangleIndices = { {meshlet 1 local indices group}, ... { meshlet n} }
    //! The local indices are an 8 bits index that can represent up to 256 entries.
    uint triangleOffset;    // In bytes from the start of the array

    //! Finding a vertex within the meshlet is done like that:
    //!     triangleOffset = currentMeshlet.triangleOffset + meshletTrIndex * 3;
    //!     localIndex_i = meshletTriangles[triangleOffset + i];    // i = triangle vertex index 0..2
    //!     vertexIndex_i =  indirectIndices[currentMeshlet.vertexOffset + localIndex_i];

    //! Amount of vertices and triangle for the mesh - based on this the arrays
    //! indirectIndices and triangleIndices are created per meshlet.
    uint vertexCount;
    uint triangleCount;
};

//------------------------------------------------------------------------------
ShaderResourceGroup MeshletsDataSrg : SRG_PerObject
{
    // For the next array review the structuee 'MeshletDescriptor'.
    // The array holds the offsets and amount of vertices and triangles per 
    // meshlet.
//    Buffer<uint4>  m_MeshletsDescriptors;
    StructuredBuffer<MeshletDescriptor> m_MeshletsDescriptors;

    // The following arrya consistes of sub arrays of triangles - one per meshlet.
    // Each uint (32 bits) represents 3 x 8 bits indices into the meshlet indices 
    // lookup array (the top byte is unused).
    Buffer<uint>    m_MeshletsTriangles;    

    // Array of sub-tables, each one represents lookup table for a meshlet that 
    // maps between a meshlet local vertex index and its global index in the mesh.
    Buffer<uint>    m_MeshletsIndicesLookup;

    // The final index buffer.
    // Meshlets Compute threads will write the calculated indices per meshlet and 
    // store it in the array if the meshlets are not culled.
    RWBuffer<uint>  m_Indices;

    // Mesh texture coordinates - will be used for debug purposes to color meshlets
    RWBuffer<uint2> m_TextureCoords;
};

//------------------------------------------------------------------------------
ShaderResourceGroup PassSrg : SRG_PerPass_WithFallback
{   
    RWStructuredBuffer<int>     m_MeshletsSharedBuffer;
}

//------------------------------------------------------------------------------
// Given the local meshlet' triangle index and the meshlet, the function calculates
// the global triangle's vertex indices and returns them along with the global 
// triangle offset.
//------------------------------------------------------------------------------
uint4 GetGlobalVertexIndicesAndTriOffset(MeshletDescriptor meshlet, uint localTriangleIdx)
{
    uint globalTriangleIndex = meshlet.triangleOffset + localTriangleIdx;
    uint localTriangle = MeshletsDataSrg::m_MeshletsTriangles[globalTriangleIndex];
    uint3 localIndices = uint3(
        (localTriangle) & 0xff,
        (localTriangle >> 8) & 0xff,
        (localTriangle >> 16) & 0xff
    );

    uint3 globalIndirection = meshlet.vertexOffset + localIndices;
    uint4 globalIndicesAndTriOffset = uint4(
        MeshletsDataSrg::m_MeshletsIndicesLookup[globalIndirection.x],
        MeshletsDataSrg::m_MeshletsIndicesLookup[globalIndirection.y],
        MeshletsDataSrg::m_MeshletsIndicesLookup[globalIndirection.z],
        globalTriangleIndex * 3
    );

    return globalIndicesAndTriOffset;
}

//------------------------------------------------------------------------------
//! The group's threads count should match either Meshlets::maxVerticesPerMeshlet
//! or Meshlets::maxTrianglesPerMeshlet depending on our algorithm for minimizing 
//! amount of work per thread and achieving max parallelizm.
//------------------------------------------------------------------------------
#define THREADS_COUNT 128
//------------------------------------------------------------------------------
[numthreads(THREADS_COUNT, 1, 1)]
void ComputeMeshletsIndexBuffer(
    uint groupIndex : SV_GroupIndex,
    uint3 groupId : SV_GroupID,
    uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint meshletId = groupId.x;
    MeshletDescriptor meshlet = MeshletsDataSrg::m_MeshletsDescriptors[meshletId];

    float2 debugTexCoord = float2( (meshletId % 3), ((meshletId / 3) % 3) ) * 0.5;

    if (groupIndex < meshlet.triangleCount)
    {   // groupIndex is used here as the index of the trianlge we process
        uint4 vtxGlobalVerticesAndTriOffset = GetGlobalVertexIndicesAndTriOffset(meshlet, groupIndex);

        // Set the global mesh index buffer for this meshlet triangle
        MeshletsDataSrg::m_Indices[vtxGlobalVerticesAndTriOffset.w] = vtxGlobalVerticesAndTriOffset.x;
        MeshletsDataSrg::m_Indices[vtxGlobalVerticesAndTriOffset.w + 1] = vtxGlobalVerticesAndTriOffset.y;
        MeshletsDataSrg::m_Indices[vtxGlobalVerticesAndTriOffset.w + 2] = vtxGlobalVerticesAndTriOffset.z;

        // Set the vertices UV according to the meshlet Id as a debug indication
        MeshletsDataSrg::m_TextureCoords[MeshletsDataSrg::m_Indices[vtxGlobalVerticesAndTriOffset.w]] = debugTexCoord;
        MeshletsDataSrg::m_TextureCoords[MeshletsDataSrg::m_Indices[vtxGlobalVerticesAndTriOffset.w + 1]] = debugTexCoord;
        MeshletsDataSrg::m_TextureCoords[MeshletsDataSrg::m_Indices[vtxGlobalVerticesAndTriOffset.w + 2]] = debugTexCoord;
    }

//    GroupMemoryBarrierWithGroupSync();
}
