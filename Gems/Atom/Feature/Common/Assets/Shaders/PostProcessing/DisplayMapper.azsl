/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

//
// ACES implementation
// This implementation is partially ported from NVIDIA HDR sample.
// https://developer.nvidia.com/high-dynamic-range-display-development
//

#include <Atom/Features/SrgSemantics.azsli>

#include <Atom/Features/PostProcessing/FullscreenPixelInfo.azsli>
#include <Atom/Features/PostProcessing/FullscreenVertex.azsli>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>
#include <Atom/Features/PostProcessing/Aces.azsli>

////////////////////////////////////////////////////////////////////////////////

ShaderResourceGroup PassSrg : SRG_PerPass
{
    Texture2D<float4> m_framebuffer;
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    // ACES spline parameters
    SegmentedSplineParamsC9 m_acesSplineParams;
    // Color transformation matrix from XYZ to the display's color primaries
    row_major float3x3 m_XYZtoDisplayPrimaries;
    // Reference white and black luminance values
    float2 m_cinemaLimits;
    // Bit flag for control the ODT shader behavior
    int m_outputDisplayTransformFlags;
    // The ODT output mode
    int m_outputDisplayTransformMode;
    // Gamma adjustment to be applied to compensate for the condition of the viewing environment.
    // Note that ACES uses a value of 0.9811 for adjusting from dark to dim surrounding.
    float m_surroundGamma;
    // Optional gamma value that is applied as basic gamma curve OETF
    float m_gamma;
}

#define DISPGAMMA_HALF  2.4h
#define OFFSET_HALF     0.055h
#define EPSILON_HALF    10e-5h

half MoncurveRHalf(
    half y, 
    half yb, 
    half rs,
    half offs,
    half oneOverGamma)
{
    // Reverse monitor curve
    half x;
    
    /*if (y >= yb)
    {
        x = (1.0h + offs) * pow(y, oneOverGamma) - offs;
    }
    else
    {
        x = y * rs;
    }*/

    x = (y >= yb) ? (1.0h + offs) * pow(y, oneOverGamma) - offs : y * rs;

    return x;
}

half SegmentedSplineC9FwdHalf(
    half x, 
    SegmentedSplineParamsC9 C)
{
    const min16int N_KNOTS_LOW = 8;
    const min16int N_KNOTS_HIGH = 8;

    // Check for negatives or zero before taking the log. If negative or zero,
    // set to OCESMIN.
    half xCheck = x;
    if (xCheck <= 0.0h)
    {
        xCheck = 1e-4h;
    }

    half logx = log10(float(xCheck));

    half logy;

    half logMidPtX = half(log10(C.midPoint.x));

    half logMinPtX = half(log10(C.minPoint.x));
    half logMinPtY = half(log10(C.minPoint.y));

    half logMaxPtX = half(log10(C.maxPoint.x));
    half logMaxPtY = half(log10(C.maxPoint.y));

    half slopeLow = half(C.slopeLow);
    half slopeHigh = half(C.slopeHigh);

    if (logx <= logMinPtX)
    {
        logy = logx * slopeLow + logMinPtY - slopeLow * logMinPtX;
    }
    else if ((logx > logMinPtX) && (logx < logMidPtX))
    {
        half knot_coord = (N_KNOTS_LOW - 1) * ((logx - logMinPtX) / (logMidPtX - logMinPtX));
        min16int j = min16int(knot_coord);
        half t = knot_coord - j;

        half3 cf = { half(C.coefs[j].x), half(C.coefs[j + 1].x), half(C.coefs[j + 2].x) };
        
        half3 monomials = { t * t, t, 1.h };
        logy = dot(monomials, mul(cf, MHalf));
    }
    else if ((logx >= logMidPtX) && (logx < logMaxPtX))
    {
        half knot_coord = (N_KNOTS_HIGH - 1) * ((logx - logMidPtX) / (logMaxPtX - logMidPtX));
        min16int j = min16int(knot_coord);
        half t = knot_coord - j;

        half3 cf = { half(C.coefs[j].y), half(C.coefs[j + 1].y), half(C.coefs[j + 2].y) };

        half3 monomials = { t * t, t, 1.0h };
        logy = dot(monomials, mul(cf, MHalf));
    }
    else
    { 
        logy = logx * slopeHigh + (logMaxPtY - slopeHigh * logMaxPtX);
    }

    return pow(10.0h, logy);
}

half SegmentedSplineC9FwdOptimizeHalf(
    half x, 
    SegmentedSplineParamsC9 C)
{
    const min16int N_KNOTS_LOW = 8;
    const min16int N_KNOTS_HIGH = 8;

    // Check for negatives or zero before taking the log. If negative or zero,
    // set to OCESMIN.
    half xCheck = x;
    if (xCheck <= 0.0h)
    {
        xCheck = 1e-4h;
    }

    half logx = log10(float(xCheck));

    half logy;

    half logMidPtX = half(log10(C.midPoint.x));

    half logMinPtX = half(log10(C.minPoint.x));
    half logMinPtY = half(log10(C.minPoint.y));

    half logMaxPtX = half(log10(C.maxPoint.x));
    half logMaxPtY = half(log10(C.maxPoint.y));

    half slopeLow = half(C.slopeLow);
    half slopeHigh = half(C.slopeHigh);

    min16int curveIndex = min16int((logx / (logMinPtX - logMaxPtX)) * 4.0h);

    half t0 = 7.0h * ((logx - logMinPtX) / (logMidPtX - logMinPtX));
    half t1 = 7.0h * ((logx - logMidPtX) / (logMaxPtX - logMidPtX));
    min16int j0 = min16int(t0);
    min16int j1 = min16int(t1);
    t0 -= j0;
    t1 -= j1;

    half val[] =
    {
        logx * slopeLow + logMinPtY - slopeLow * logMinPtX,
        dot(half3(t0 * t0, t0, 1.0h), mul(half3(C.coefs[j0].x, C.coefs[j0+1].x, C.coefs[j0+2].x), MHalf)),
        dot(half3(t1 * t1, t1, 1.0h), mul(half3(C.coefs[j1].x, C.coefs[j1+1].x, C.coefs[j1+2].x), MHalf)),
        logx * slopeHigh + (logMaxPtY - slopeHigh * logMaxPtX)
    };

#if 0
    if (logx <= logMinPtX)
    {
        logy = logx * slopeLow + logMinPtY - slopeLow * logMinPtX;
    }
    else if ((logx > logMinPtX) && (logx < logMidPtX))
    {
        half knot_coord = (N_KNOTS_LOW - 1) * ((logx - logMinPtX) / (logMidPtX - logMinPtX));
        min16int j = min16int(knot_coord);
        half t = knot_coord - j;

        half3 cf = { half(C.coefs[j].x), half(C.coefs[j + 1].x), half(C.coefs[j + 2].x) };
        
        half3 monomials = { t * t, t, 1.h };
        logy = dot(monomials, mul(cf, MHalf));
    }
    else if ((logx >= logMidPtX) && (logx < logMaxPtX))
    {
        half knot_coord = (N_KNOTS_HIGH - 1) * ((logx - logMidPtX) / (logMaxPtX - logMidPtX));
        min16int j = min16int(knot_coord);
        half t = knot_coord - j;

        half3 cf = { half(C.coefs[j].y), half(C.coefs[j + 1].y), half(C.coefs[j + 2].y) };

        half3 monomials = { t * t, t, 1.0h };
        logy = dot(monomials, mul(cf, MHalf));
    }
    else
    { 
        logy = logx * slopeHigh + (logMaxPtY - slopeHigh * logMaxPtX);
    }
#endif // #if 0

    return pow(10.0h, val[curveIndex]);
}

half YToLinearCVHalf(
    half Y, 
    half Ymax, 
    half Ymin)
{
    return (Y - Ymin) / (Ymax - Ymin);
}

half SigmoidShaperHalf(half x)
{
    // Sigmoid function in the range 0 to 1 spanning -2 to +2.
    half t = max(1.0h - abs(x * 0.5h), 0.0h);
    half y = 1.0h + sign(x) * (1.0h - t * t);

    return y * 0.5h;
}

half RGBToYcHalf(
    half3 rgb, 
    half ycRadiusWeight = 1.75h)
{
    // Converts RGB to a luminance proxy, here called YC
    // YC is ~ Y + K * Chroma
    // Constant YC is a cone-shaped surface in RGB space, with the tip on the 
    // neutral axis, towards white.
    // YC is normalized: RGB 1 1 1 maps to YC = 1
    //
    // ycRadiusWeight defaults to 1.75, although can be overridden in function 
    // call to RGBToYc
    // ycRadiusWeight = 1 -> YC for pure cyan, magenta, yellow == YC for neutral 
    // of same value
    // ycRadiusWeight = 2 -> YC for pure red, green, blue  == YC for  neutral of 
    // same value.

    half r = rgb[0];
    half g = rgb[1];
    half b = rgb[2];

    half chroma = sqrt(b*(b - g) + g*(g - r) + r*(r - b));

    return (b + g + r + ycRadiusWeight * chroma) / 3.0h;
}

half RGBToSaturationHalf(
    half3 rgb)
{
    return (max(MaxF3Half(rgb), EPSILON_HALF) - max(MinF3Half(rgb), EPSILON_HALF)) / max(MaxF3Half(rgb), 1e-2h);
}

half GlowFwdHalf(
    half ycIn, 
    half glowGainIn, 
    half glowMid)
{
    half glowGainOut;

    if (ycIn <= 2.0h / 3.0h * glowMid)
    {
        glowGainOut = glowGainIn;
    }
    else if (ycIn >= 2.0h * glowMid)
    {
        glowGainOut = 0.0h;
    }
    else
    {
        glowGainOut = glowGainIn * (glowMid / ycIn - 1.0h / 2.0h);
    }

    return glowGainOut;
}

half CenterHueHalf(
    half hue, 
    half centerH)
{
    half hueCentered = hue - centerH;
    if (hueCentered < -180.0h)
    {
        hueCentered = hueCentered + 360.0h;
    }
    else if (hueCentered > 180.0h)
    {
        hueCentered = hueCentered - 360.0h;
    }
    return hueCentered;
}

half CubicBasisShaperHalf(
    half x, 
    half w   /* full base width of the shaper function (in degrees)*/)
{
    const half M[4][4] =
    {
        { -1.0h / 6.0h,  3.0h / 6.0h, -3.0h / 6.0h, 1.0h / 6.0h },
        {  3.0h / 6.0h, -6.0h / 6.0h,  3.0h / 6.0h, 0.0h / 6.0h },
        { -3.0h / 6.0h,  0.0h / 6.0h,  3.0h / 6.0h, 0.0h / 6.0h },
        {  1.0h / 6.0h,  4.0h / 6.0h,  1.0h / 6.0h, 0.0h / 6.0h }
    };

    half knots[5] =
    {
        -w / 2.0h,
        -w / 4.0h,
        0.0h,
        w / 4.0h,
        w / 2.0h
    };

    half y = 0;
    if ((x > knots[0]) && (x < knots[4]))
    {
        half knot_coord = (x - knots[0]) * 4.0h / w;
        min16int j = knot_coord;
        half t = knot_coord - j;

        half monomials[4] = { t*t*t, t*t, t, 1.0h };

        // (if/else structure required for compatibility with CTL < v1.5.)
        if (j == 3)
        {
            y = monomials[0] * M[0][0] + monomials[1] * M[1][0] +
                monomials[2] * M[2][0] + monomials[3] * M[3][0];
        }
        else if (j == 2)
        {
            y = monomials[0] * M[0][1] + monomials[1] * M[1][1] +
                monomials[2] * M[2][1] + monomials[3] * M[3][1];
        }
        else if (j == 1)
        {
            y = monomials[0] * M[0][2] + monomials[1] * M[1][2] +
                monomials[2] * M[2][2] + monomials[3] * M[3][2];
        }
        else if (j == 0)
        {
            y = monomials[0] * M[0][3] + monomials[1] * M[1][3] +
                monomials[2] * M[2][3] + monomials[3] * M[3][3];
        }
        else
        {
            y = 0.0h;
        }
    }

    return y * 3.0h / 2.0h;
}

half3x3 CalcSatAdjustMatrixHalf(
    half sat, 
    half3 rgb2Y)
{
    //
    // This function determines the terms for a 3x3 saturation matrix that is
    // based on the luminance of the input.
    //
    half3x3 M;
    M[0][0] = (1.0 - sat) * rgb2Y[0] + sat;
    M[1][0] = (1.0 - sat) * rgb2Y[0];
    M[2][0] = (1.0 - sat) * rgb2Y[0];

    M[0][1] = (1.0 - sat) * rgb2Y[1];
    M[1][1] = (1.0 - sat) * rgb2Y[1] + sat;
    M[2][1] = (1.0 - sat) * rgb2Y[1];

    M[0][2] = (1.0 - sat) * rgb2Y[2];
    M[1][2] = (1.0 - sat) * rgb2Y[2];
    M[2][2] = (1.0 - sat) * rgb2Y[2] + sat;

    // CTL matrix indexing is transposed, so the transpose in the reference code is omitted

    return M;
}

struct SegmentedSplineParamsC5Half
{
    half coefsLow[6];      // coefs for B-spline between minPoint and midPoint (units of log luminance)
    half coefsHigh[6];     // coefs for B-spline between midPoint and maxPoint (units of log luminance)
    half2 minPoint;        // {luminance, luminance} linear extension below this
    half2 midPoint;        // {luminance, luminance} 
    half2 maxPoint;        // {luminance, luminance} linear extension above this
    half slopeLow;         // log-log slope of low linear extension
    half slopeHigh;        // log-log slope of high linear extension
};

static const SegmentedSplineParamsC5Half RRT_PARAMS_HALF =
{
    // coefsLow[6]
    { -4.0000000000h, -4.0000000000h, -3.1573765773h, -0.4852499958h, 1.8477324706h, 1.8477324706h },
    // coefsHigh[6]
    { -0.7185482425h, 2.0810307172h, 3.6681241237h, 4.0000000000h, 4.0000000000h, 4.0000000000h },
    { 0.18h*pow(2.h, -15.0h), 0.0001h },    // minPoint
    { 0.18h, 4.8h },    // midPoint  
    { 0.18h*pow(2.0h, 18.0h), 10000.0h },    // maxPoint
    0.0h,  // slopeLow
    0.0h   // slopeHigh
};


half SegmentedSplineC5FwdHalf (
    half x,  
    SegmentedSplineParamsC5 C = RRT_PARAMS)
{
    #define N_KNOTS_LOW  4
    #define N_KNOTS_HIGH  4

    // Check for negatives or zero before taking the log. If negative or zero,
    // set to ACESMIN.
    half xCheck = x;
    if (xCheck <= 0.0h) 
    {
        xCheck = 0.000061h; //pow(2.0h, -14.0h);
    }

    half logx = log10(float(xCheck));

    half logMidPtX = half(log10(float(C.midPoint.x)));

    half logMinPtX = half(log10(float(C.minPoint.x)));
    half logMinPtY = half(log10(float(C.minPoint.y)));

    half logMaxPtX = half(log10(float(C.maxPoint.x)));
    half logMaxPtY = half(log10(float(C.maxPoint.y)));

    half logy;

    if (logx <= logMinPtX)
    {
        logy = logx * half(C.slopeLow) + half(logMinPtY - C.slopeLow * logMinPtX);
    }
    else if ((logx > logMinPtX) && (logx < logMidPtX))
    {
        half knot_coord = (N_KNOTS_LOW - 1) * half((logx - logMinPtX) / (logMidPtX - logMinPtX));
        min16int j = knot_coord;
        half t = frac(knot_coord); //knot_coord - j;

        half3 cf = { half(C.coefsLow[j]), half(C.coefsLow[j + 1]), half(C.coefsLow[j + 2]) };

        half3 monomials = { t * t, t, 1.0h };
        logy = dot(monomials, mul(cf, MHalf));
    }
    else if ((logx >= logMidPtX) && (logx < logMaxPtX))
    {
        half knot_coord = (N_KNOTS_HIGH - 1) * half((logx - logMidPtX) / (logMaxPtX - logMidPtX));
        min16int j = knot_coord;
        half t = frac(knot_coord); //knot_coord - j;

        half3 cf = { half(C.coefsHigh[j]), half(C.coefsHigh[j + 1]), half(C.coefsHigh[j + 2]) };

        half3 monomials = { t * t, t, 1.0h };
        logy = dot(monomials, mul(cf, MHalf));
    }
    else
    {
        logy = logx * half(C.slopeHigh) + half(logMaxPtY - C.slopeHigh * logMaxPtX);
    }

    return pow(10.0h, logy);
}

#if 0
half SegmentedSplineC5FwdOptimizeHalf (
    half x,  
    SegmentedSplineParamsC5Half C = RRT_PARAMS_HALF)
{
    // Check for negatives or zero before taking the log. If negative or zero,
    // set to ACESMIN.
    half xCheck = x;
    if (xCheck <= 0.0h) 
    {
        xCheck = 0.000061h;
    }

    half logx = log10(float(xCheck));

    half logMidPtX = half(log10(float(C.midPoint.x)));

    half logMinPtX = half(log10(float(C.minPoint.x)));
    half logMinPtY = half(log10(float(C.minPoint.y)));

    half logMaxPtX = half(log10(float(C.maxPoint.x)));
    half logMaxPtY = half(log10(float(C.maxPoint.y)));

    half diff = logx - logMinPtX;
    min16int curveIndex = min16int((diff / (logMaxPtX - logMinPtX)) * 4.0h);
    
    half t0 = 3.0h * ((logx - logMinPtX) / (logMidPtX - logMinPtX));
    half t1 = 3.0h * ((logx - logMidPtX) / (logMaxPtX - logMidPtX));
    min16int j0 = min16int(t0);
    min16int j1 = min16int(t1);
    t0 = frac(t0);
    t1 = frac(t1);
    half val[4] = 
    {
        logx * slopeLow + logMinPtY - C.slopeLow * logMinPtX,
        dot(half3(t0 * t0, t0, 1.0h), mul(half3(C.coefsLow[j0].x, C.coefsLow[j0+1].x, C.coefsLow[j0+2].x), MHalf)),
        dot(half3(t1 * t1, t1, 1.0h), mul(half3(C.coefsHigh[j1].x, C.coefsHigh[j1+1].x, C.coefsHigh[j1+2].x), MHalf)),
        logx * slopeHigh + (logMaxPtY - C.slopeHigh * logMaxPtX)
    };

    return pow(10.0h, val[curveIndex]);
}
#endif // #if 0

half3 ReferenceRenderingTransformHalf(
    half3 rgbIn)
{
    // "Glow" module constants
    #define RRT_GLOW_GAIN       0.05h
    #define RRT_GLOW_MID        0.08h

    // Red modifier constants
    #define RRT_RED_SCALE       0.82h
    #define RRT_RED_PIVOT       0.03h
    #define RRT_RED_HUE         0.0h
    #define RRT_RED_WIDTH       135.h

    #define RRT_SAT_FACTOR      0.96h

    // Glow module
    half saturation = RGBToSaturationHalf(rgbIn);
    half ycIn = RGBToYcHalf(rgbIn);
    half s = SigmoidShaperHalf((saturation - 0.4h) / 0.2h);
    half addedGlow = 1.0h + GlowFwdHalf(ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);

    half3 aces = addedGlow * rgbIn;

    // Red modifier
    half hue = RGBToHueHalf(aces);
    half centeredHue = CenterHueHalf(hue, RRT_RED_HUE);
    half hueWeight = CubicBasisShaperHalf(centeredHue, RRT_RED_WIDTH);

    aces[0] = aces[0] + hueWeight * saturation * (RRT_RED_PIVOT - aces[0]) * (1.0h - RRT_RED_SCALE);

    // ACES to RGB rendering space
    aces = max(aces, 0.0h);  // avoids saturated negative colors from becoming positive in the matrix

    half3 rgbPre = mul(AP0ToAP1MatHalf, aces);

    rgbPre = clamp(rgbPre, 0.0h, HALF_MAX_HALF);

    // Global desaturation
    
    const half3x3 RRT_SAT_MAT = CalcSatAdjustMatrixHalf(RRT_SAT_FACTOR, AP1RGBToYHalf);

    rgbPre = mul(RRT_SAT_MAT, rgbPre);

    // Apply the tonescale independently in rendering-space RGB
    half3 rgbPost;
    rgbPost[0] = SegmentedSplineC5FwdHalf(rgbPre[0]);
    rgbPost[1] = SegmentedSplineC5FwdHalf(rgbPre[1]);
    rgbPost[2] = SegmentedSplineC5FwdHalf(rgbPre[2]);

    // RGB rendering space to OCES

    return mul(AP1ToAP0MatHalf, rgbPost);
}

half3 OutputDeviceTransformHalf(
    const half3 oces, 
    OutputTransformParameters otParams)
{
    // OCES to RGB rendering space
    half3 rgbPre = mul(AP0ToAP1MatHalf, oces);

    // Apply the tonescale independently in rendering-space RGB
    half3 rgbPost;
    rgbPost[0] = SegmentedSplineC9FwdHalf(rgbPre[0], otParams.acesSplineParams);
    rgbPost[1] = SegmentedSplineC9FwdHalf(rgbPre[1], otParams.acesSplineParams);
    rgbPost[2] = SegmentedSplineC9FwdHalf(rgbPre[2], otParams.acesSplineParams);

    // A linear mapping from the cinema limit range to a value between 0.0, to 1.0.
    // Scale luminance to linear code value
    half3 linearCV = (rgbPost - half3(otParams.cinemaLimits.x, otParams.cinemaLimits.x, otParams.cinemaLimits.x)) / half(otParams.cinemaLimits.y - otParams.cinemaLimits.x);

    /*if (otParams.outputDisplayTransformFlags & APPLY_ALTER_SURROUND)
    {
        // Apply gamma adjustment to compensate for dim surround
        linearCV = AlterSurroundHalf(linearCV, half(otParams.surroundGamma));
    }

    if (otParams.outputDisplayTransformFlags & APPLY_DESATURATION)
    {
        // Apply desaturation to compensate for luminance difference
        // Saturation compensation factor
        const half ODT_SAT_FACTOR = 0.93h;
        const half3x3 ODT_SAT_MAT = CalcSatAdjustMatrixHalf(ODT_SAT_FACTOR, AP1RGBToYHalf);
        linearCV = mul(ODT_SAT_MAT, linearCV);
    }*/

    // Convert to display primary encoding
    // Rendering space RGB to XYZ
    half3 XYZ = mul(AP1ToXYZMatHalf, linearCV);

    /*if (otParams.outputDisplayTransformFlags & APPLY_CAT_D60TOD65)
    {
        // Apply Color appearance transform (CAT) from ACES white point to assumed observer adapted white point
        // PC content usually always assumes a D65 whitespace, so this should usually be enabled.
        XYZ = mul(D60ToD65CatHalf, XYZ);
    }*/

    // CIE XYZ to display primaries
    linearCV = mul(half3x3(otParams.XYZtoDisplayPrimaries), XYZ);

    // Encode linear code values with transfer function
    half3 outputCV = linearCV;

    /*if (otParams.outputDisplayTransformMode == OUTPUT_SRGB)
    { 
        // SRGB
        // clamp 0/1 and encode 
        linearCV = clamp(linearCV, 0.h, 1.h);

        const half oneOverGamma = 1.0h / DISPGAMMA_HALF;
        const half yb = pow(OFFSET_HALF * DISPGAMMA_HALF / ((DISPGAMMA_HALF - 1.0h) * (1.0h + OFFSET_HALF)), DISPGAMMA_HALF);
        const half rs = pow((DISPGAMMA_HALF - 1.0h) / OFFSET_HALF, DISPGAMMA_HALF - 1.0h) * pow((1.0h + OFFSET_HALF) * oneOverGamma, DISPGAMMA_HALF);
        
        outputCV[0] = MoncurveRHalf(linearCV[0], yb, rs, oneOverGamma, OFFSET_HALF);
        outputCV[1] = MoncurveRHalf(linearCV[1], yb, rs, oneOverGamma, OFFSET_HALF);
        outputCV[2] = MoncurveRHalf(linearCV[2], yb, rs, oneOverGamma, OFFSET_HALF);
    }
    else if (otParams.outputDisplayTransformMode == OUTPUT_PERCEPTUALQUANTIZER)
    {
        //scale to bring the ACES data back to the proper range
        linearCV[0] = LinearCVToYHalf(linearCV[0], half(otParams.cinemaLimits.y), half(otParams.cinemaLimits.x));
        linearCV[1] = LinearCVToYHalf(linearCV[1], half(otParams.cinemaLimits.y), half(otParams.cinemaLimits.x));
        linearCV[2] = LinearCVToYHalf(linearCV[2], half(otParams.cinemaLimits.y), half(otParams.cinemaLimits.x));

        linearCV = max(linearCV, 0.h);

        // Encode with PQ transfer function
        outputCV = PerceptualQuantizerRevF3Half(linearCV);
    }
    else if (otParams.outputDisplayTransformMode == OUTPUT_LDR)
    */
    {
        // LDR mode, clamp 0/1 and encode with given gamma value for the OETF
        linearCV = clamp(linearCV, 0.h, 1.h);

        outputCV = outputCV > 0.0h ? pow(linearCV, 1.0h / half(otParams.gamma)) : 0.0h;
    }

    return outputCV;
}


////////////////////////////////////////////////////////////////////////////////
// A entry point of pixel shader.
PSOutput MainPS(VSOutput IN)
{
    PSOutput OUT;

    OutputTransformParameters outputTransformParams;
    outputTransformParams.outputDisplayTransformFlags = PassSrg::m_outputDisplayTransformFlags;
    outputTransformParams.outputDisplayTransformMode = PassSrg::m_outputDisplayTransformMode;
    outputTransformParams.cinemaLimits = PassSrg::m_cinemaLimits;
    outputTransformParams.acesSplineParams = PassSrg::m_acesSplineParams;
    outputTransformParams.XYZtoDisplayPrimaries = PassSrg::m_XYZtoDisplayPrimaries;
    outputTransformParams.surroundGamma = PassSrg::m_surroundGamma;
    outputTransformParams.gamma = PassSrg::m_gamma;

    half3 color = PassSrg::m_framebuffer.Sample(PassSrg::LinearSampler, IN.m_texCoord).rgb;

    // const float a = 2.51f;
    // const float b = 0.03f;
    // const float c = 2.43f;
    // const float d = 0.59f;
    // const float e = 0.14f;
    // half3 ret = saturate((color*(a*color+b))/(color*(c*color+d)+e));

    // Convert to ACEScg to ACES color space
    half3 aces = mul(AP1ToAP0MatHalf, half3(color.rgb));
    
    half3 oces = ReferenceRenderingTransformHalf(aces);
    OUT.m_color.rgb = float3(OutputDeviceTransformHalf(oces, outputTransformParams));
    OUT.m_color.w = 1;

    return OUT;
}
