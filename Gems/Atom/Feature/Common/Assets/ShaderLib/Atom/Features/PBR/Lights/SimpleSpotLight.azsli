/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <Atom/Features/PBR/Lights/LightTypesCommon.azsli>

void ApplySimpleSpotLight(ViewSrg::SimpleSpotLight light, Surface surface, inout LightingData lightingData)
{
    float3 posToLight = light.m_position - surface.position;
    
    float3 dirToLight = normalize(posToLight);
    float dotWithDirection = dot(dirToLight, -normalize(light.m_direction));

    // If outside the outer cone angle return.
    if (dotWithDirection < light.m_cosOuterConeAngle)
    {
        return;
    }

    float d2 = dot(posToLight, posToLight); // light distance squared
    float falloff = d2 * light.m_invAttenuationRadiusSquared;

    // Only calculate shading if light is in range
    if (falloff < 1.0f)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        float radiusAttenuation = 1.0 - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;
        
        // Standard quadratic falloff
        d2 = max(0.001 * 0.001, d2); // clamp the light to at least 1mm away to avoid extreme values.
        float3 lightIntensity = (light.m_rgbIntensityCandelas / d2) * radiusAttenuation;
        float3 posToLightDir = normalize(posToLight);

        if (dotWithDirection < light.m_cosInnerConeAngle) // in penumbra
        {   
            // Normalize into 0.0 - 1.0 space.
            float penumbraMask = (dotWithDirection - light.m_cosOuterConeAngle) / (light.m_cosInnerConeAngle - light.m_cosOuterConeAngle);
            
            // Apply smoothstep
            penumbraMask = penumbraMask * penumbraMask * (3.0 - 2.0 * penumbraMask);
            
            lightIntensity *= penumbraMask;
        }

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLighting(surface, lightingData, lightIntensity, posToLightDir);

        // Specular contribution
        lightingData.specularLighting += GetSpecularLighting(surface, lightingData, lightIntensity, posToLightDir);
    }
}

void ApplySimpleSpotLights(Surface surface, inout LightingData lightingData)
{
    lightingData.tileIterator.LoadAdvance();
                
    while( !lightingData.tileIterator.IsDone() ) 
    { 
        uint currLightIndex = lightingData.tileIterator.GetValue(); 
        lightingData.tileIterator.LoadAdvance();
    
        ViewSrg::SimpleSpotLight light = ViewSrg::m_simpleSpotLights[currLightIndex];
        ApplySimpleSpotLight(light, surface, lightingData);
    }
}


void ApplySimpleSpotLightHalf(
    ViewSrg::SimpleSpotLight light, 
    Surface surface, 
    inout LightingData lightingData)
{
    half3 posToLight = light.m_position - surface.position;
    
    half3 dirToLight = normalize(posToLight);
    half dotWithDirection = dot(dirToLight, -normalize(light.m_direction));

    // If outside the outer cone angle return.
    if (dotWithDirection < light.m_cosOuterConeAngle)
    {
        return;
    }

    half d2 = dot(posToLight, posToLight); // light distance squared
    half falloff = d2 * light.m_invAttenuationRadiusSquared;

    // Only calculate shading if light is in range
    if (falloff < 1.0h)
    {
        // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
        half radiusAttenuation = 1.0h - (falloff * falloff);
        radiusAttenuation = radiusAttenuation * radiusAttenuation;
        
        // Standard quadratic falloff
        d2 = max(0.001h * 0.001h, d2); // clamp the light to at least 1mm away to avoid extreme values.
        half3 lightIntensity = (light.m_rgbIntensityCandelas / d2) * radiusAttenuation;
        half3 posToLightDir = normalize(posToLight);

        if (dotWithDirection < light.m_cosInnerConeAngle) // in penumbra
        {   
            // Normalize into 0.0 - 1.0 space.
            float penumbraMask = (dotWithDirection - light.m_cosOuterConeAngle) / (light.m_cosInnerConeAngle - light.m_cosOuterConeAngle);
            
            // Apply smoothstep
            penumbraMask = penumbraMask * penumbraMask * (3.0h - 2.0h * penumbraMask);
            
            lightIntensity *= penumbraMask;
        }

        // Diffuse contribution
        lightingData.diffuseLighting += GetDiffuseLightingHalf(surface, lightingData, lightIntensity, posToLightDir);

        // Specular contribution
        lightingData.specularLighting += GetSpecularLightingHalf(surface, lightingData, lightIntensity, posToLightDir);
    }
}

void ApplySimpleSpotLightsHalf(Surface surface, inout LightingData lightingData)
{
    for(min16int i = 0; i < ViewSrg::m_simpleSpotLightCount; i++)
    {
        ApplySimpleSpotLightHalf(ViewSrg::m_simpleSpotLights[i], surface, lightingData);
    }
}
