/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#ifndef MULTILAYER
#define MULTILAYER 0
#endif

#ifndef ENABLE_ALPHA_CLIP
#define ENABLE_ALPHA_CLIP 0
#endif

struct VSInput
{
    float3 m_position : POSITION;
    float2 m_uv0 : UV0;
    float2 m_uv1 : UV1;

    // only used for parallax depth calculation
    float3 m_normal : NORMAL;
    float4 m_tangent : TANGENT; 
    float3 m_bitangent : BITANGENT; 

    float4 m_optional_color : COLOR0;

#if MULTILAYER
    // This gets set automatically by the system at runtime only if it's available.
    // There is a soft naming convention that associates this with o_blendMask_isBound, which will be set to true whenever m_optional_blendMask is available.
    // (search "m_optional_" in ShaderVariantAssetBuilder for details on the naming convention).
    // [GFX TODO][ATOM-14475]: Come up with a more elegant way to associate the isBound flag with the input stream.
    float4 m_optional_blendMask : COLOR0;
#endif
};
 
struct VSDepthOutput
{
    // "centroid" is needed for SV_Depth to compile
    precise linear centroid float4 m_position : SV_Position;
    float2 m_uv[UvSetCount] : UV1;

    // only used for parallax depth calculation
    float3 m_normal : NORMAL;
    float3 m_tangent : TANGENT; 
    float3 m_bitangent : BITANGENT; 
    float3 m_worldPosition : UV0;

#if MULTILAYER
    float3 m_blendMask : UV3;
#endif
};

VSDepthOutput MainVS(VSInput IN)
{
    VSDepthOutput OUT;
 
    float4x4 objectToWorld = GetObjectToWorld();
    float4 worldPosition = mul(objectToWorld, float4(IN.m_position, 1.0));
    OUT.m_worldPosition = worldPosition.xyz;

    OUT.m_position = float4(IN.m_position, 1.0);

    float2 uvs[UvSetCount] = { IN.m_uv0, IN.m_uv1 };
    TransformUvs(uvs, OUT.m_uv);

    if(ShouldHandleParallaxInDepthShaders())
    {
        OUT.m_worldPosition = worldPosition.xyz;

        float3x3 objectToWorldIT = GetNormalToWorld();
        ConstructTBN(IN.m_normal, IN.m_tangent, IN.m_bitangent, objectToWorld, objectToWorldIT, OUT.m_normal, OUT.m_tangent, OUT.m_bitangent);
    }

    // Bending
    if (o_color_isBound) {
        float currentTime = SceneSrg::m_time;

        // Overall wind
        float2 wind = float2(MaterialSrg::m_windDirX, MaterialSrg::m_windDirY);
        float bendStr = MaterialSrg::m_bendingStrength;
        float2 amp = float2(wind.x * 0.4 + wind.y * 0.2, wind.y * 0.4 - wind.x * 0.2);
        float2 freq = float2(0.9, 0.9 * 1.125);
        float2 phase = float2(worldPosition.x * 0.08f, worldPosition.y * 0.08f);

        float2 addBending = float2(sin(currentTime * freq.x + phase.x) * amp.x, sin(currentTime * freq.y + phase.y) * amp.y);

        float4 result;
        result.x = addBending.x + wind.x;
        result.y = addBending.y + wind.y;
        result.z = sqrt(wind.x * wind.x + wind.y * wind.y);
        result *= bendStr * 2.5;
        float2 totalBending = addBending + wind;
        result.w = sqrt(totalBending.x * totalBending.x + totalBending.y * totalBending.y) * 0.3f; 

        // Wind
        float fAnimAmplitudeWav1 = (MaterialSrg::m_ampWav0 + MaterialSrg::m_ampWav2)*0.5;
        float4 vWavesAmp = float4(MaterialSrg::m_ampWav0*0.573, MaterialSrg::m_ampWav0, fAnimAmplitudeWav1, MaterialSrg::m_ampWav2) * 0.01;
        const float4 vWavesPhases = float4(0.5 + 0.3799, 0.5 + 0.575, 0.5 + 0.795, 0.5 + 1.099);

        float fAnimPhase = dot(IN.m_position, MaterialSrg::m_phase);
        float fSpeed = MaterialSrg::m_frequency;

        float4 vWaves = (frac((currentTime + fAnimPhase) * vWavesPhases) * 2.0 - 1.0) *fSpeed;
        vWaves = abs(frac(vWaves + 0.5) * 2.0 - 1.0);

        float fWaveSum = dot(vWavesAmp.xyzw, vWaves.xyzw);

        OUT.m_position.xyz += fWaveSum * IN.m_optional_color.w * IN.m_normal;

        // Detail bending
        float dfSpeed = result.w;

        float fEdgeInfo = IN.m_optional_color.x;
        float fBranchPhase = IN.m_optional_color.y;
        float fBranchBendAmount = 1-IN.m_optional_color.z;

        // Phases (object, vertex, branch)
        float fObjPhase = (dot(worldPosition.xyz, 2));
        fBranchPhase += fObjPhase;
        float fVtxPhase = (dot(OUT.m_position.xyz, fBranchPhase)); 

        // Detail bending for leaves/grass
        // x: is used for edges, y is used for branch
        float2 vWavesIn = currentTime;
        vWavesIn += float2(fVtxPhase, fBranchPhase);

        float4 dvWaves = (frac(vWavesIn.xxyy * float4(1.975, 0.793, 0.375,  0.193)) * 2.0 - 1.0) * MaterialSrg::m_detailFreq * dfSpeed;
        dvWaves = abs(frac(dvWaves + 0.5) * 2.0 - 1.0);

        // x: is used for edges, y is used for branches
        float2 vWavesSum = ((dvWaves.xz + dvWaves.yw));

        // Edge and branch bending (xy is used for edges, z for branches)
        OUT.m_position.xyz += vWavesSum.xxy * float3(fEdgeInfo * MaterialSrg::m_detailLeafAmp * IN.m_normal.xy, fBranchBendAmount * MaterialSrg::m_detailBranchAmp);

        // Bend factor
        float fBF = OUT.m_position.z * result.z;
        fBF *= fBF; 

        float fLength = length(OUT.m_position.xyz); 

        float3 vNewPos = OUT.m_position.xyz;
        vNewPos.xy += float2(result.x, result.y) * fBF;

        OUT.m_position.xyz = normalize(vNewPos) * fLength;  
    }

    worldPosition = mul(objectToWorld, OUT.m_position);
    OUT.m_worldPosition = worldPosition.xyz;
    OUT.m_position = mul(ViewSrg::m_viewProjectionMatrix, worldPosition);

#if MULTILAYER
    if(o_blendMask_isBound)
    {
        OUT.m_blendMask = IN.m_optional_blendMask.rgb;
    }
    else
    {
        OUT.m_blendMask = float3(0,0,0);
    }
#endif

    return OUT;
}

struct PSDepthOutput
{
    precise float m_depth : SV_Depth;
};

PSDepthOutput MainPS(VSDepthOutput IN, bool isFrontFace : SV_IsFrontFace)
{
    const float3 vertexNormal = normalize(IN.m_normal);

    PSDepthOutput OUT;

    OUT.m_depth = IN.m_position.z;

    if(ShouldHandleParallaxInDepthShaders())
    {
        float3 tangents[UvSetCount] = { IN.m_tangent, IN.m_tangent };
        float3 bitangents[UvSetCount] = { IN.m_bitangent, IN.m_bitangent };

        for (int i = 0; i != UvSetCount; ++i)
        {
            EvaluateTangentFrame(
                vertexNormal,
                IN.m_worldPosition, 
                isFrontFace,
                IN.m_uv[i],
                i,
                IN.m_tangent,
                IN.m_bitangent,
                tangents[i],
                bitangents[i]);
        }

#if MULTILAYER
        MultilayerSetPixelDepth(IN.m_blendMask, IN.m_worldPosition, vertexNormal, tangents, bitangents, IN.m_uv, isFrontFace, OUT.m_depth);
#else
        SetPixelDepth(IN.m_worldPosition, vertexNormal, tangents, bitangents, IN.m_uv, isFrontFace, OUT.m_depth);
#endif
    }
    
#if ENABLE_ALPHA_CLIP
    GetAlphaAndClip(IN.m_uv);
#endif

    return OUT;
}
