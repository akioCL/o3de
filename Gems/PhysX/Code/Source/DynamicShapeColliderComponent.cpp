#include "PhysX_precompiled.h"
#include "DynamicShapeColliderComponent.h"

#include <ShapeColliderComponent.h>
#include <PhysX/SystemComponentBus.h>

#include <AzCore/Component/Entity.h>
#include <AzCore/std/smart_ptr/make_shared.h>
#include <AzCore/Math/Geometry2DUtils.h>
#include <AzFramework/Physics/ShapeConfiguration.h>

#include <LmbrCentral/Shape/ShapeComponentBus.h>
#include <LmbrCentral/Shape/BoxShapeComponentBus.h>
#include <LmbrCentral/Shape/CapsuleShapeComponentBus.h>
#include <LmbrCentral/Shape/SphereShapeComponentBus.h>
#include <LmbrCentral/Shape/CylinderShapeComponentBus.h>

namespace PhysX
{
    AZ::EntityId ShapeConfigUpdateContext::GetEntityId() const
    {
        return m_entity->GetId();
    }

    void DynamicShapeColliderBase::UpdateShapeConfigs(ShapeConfigs& shapeConfigs, PolygonPrismMeshUtils::Mesh2D& mesh, AZ::Entity* entity)
    {
        ShapeConfigUpdateContext ctx(shapeConfigs, mesh, entity, *this);
        ctx.UpdateShapeConfigs();
    }

    void ShapeConfigUpdateContext::UpdateShapeConfigs()
    {
        m_shapeConfigs.clear();

        AZ::Crc32 shapeCrc;
        LmbrCentral::ShapeComponentRequestsBus::EventResult(shapeCrc, GetEntityId(),
            &LmbrCentral::ShapeComponentRequests::GetShapeType);

        // using if blocks because switch statements aren't supported for values generated by the crc macro
        if (shapeCrc == ShapeConstants::Box)
        {
            m_state.m_shapeType = ShapeType::Box;
            UpdateBoxConfig();
        }

        else if (shapeCrc == ShapeConstants::Capsule)
        {
            m_state.m_shapeType = ShapeType::Capsule;
            UpdateCapsuleConfig();
        }

        else if (shapeCrc == ShapeConstants::Sphere)
        {
            m_state.m_shapeType = ShapeType::Sphere;
            UpdateSphereConfig();
        }

        else if (shapeCrc == ShapeConstants::PolygonPrism)
        {
            m_state.m_shapeType = ShapeType::PolygonPrism;
            UpdatePolygonPrismDecomposition();
        }

        else if (shapeCrc == ShapeConstants::Cylinder)
        {
            m_state.m_shapeType = ShapeType::Cylinder;
            UpdateCylinderConfig();
        }

        else
        {
            m_state.m_shapeType = !shapeCrc ? ShapeType::None : ShapeType::Unsupported;
            AZ_Warning("PhysX Shape Collider Component", m_state.m_shapeTypeWarningIssued, "Unsupported shape type for "
                "entity \"%s\". The following shapes are currently supported - box, capsule, cylinder, sphere, polygon prism.",
                GetEntity()->GetName().c_str());
            m_state.m_shapeTypeWarningIssued = true;
        }
    }

    void ShapeConfigUpdateContext::UpdateBoxConfig()
    {
        AZ::Vector3 boxDimensions = AZ::Vector3::CreateOne();
        LmbrCentral::BoxShapeComponentRequestsBus::EventResult(boxDimensions, GetEntityId(),
            &LmbrCentral::BoxShapeComponentRequests::GetBoxDimensions);
        m_shapeConfigs.emplace_back(AZStd::make_shared<Physics::BoxShapeConfiguration>(boxDimensions));
    }

    void ShapeConfigUpdateContext::UpdateCapsuleConfig()
    {
        LmbrCentral::CapsuleShapeConfig lmbrCentralCapsuleShapeConfig;
        LmbrCentral::CapsuleShapeComponentRequestsBus::EventResult(lmbrCentralCapsuleShapeConfig, GetEntityId(),
            &LmbrCentral::CapsuleShapeComponentRequests::GetCapsuleConfiguration);
        m_shapeConfigs.emplace_back(AZStd::make_shared<Physics::CapsuleShapeConfiguration>(
            Utils::ConvertFromLmbrCentralCapsuleConfig(lmbrCentralCapsuleShapeConfig)));
    }

    void ShapeConfigUpdateContext::UpdateSphereConfig()
    {
        float radius = 0.0f;
        LmbrCentral::SphereShapeComponentRequestsBus::EventResult(radius, GetEntityId(),
            &LmbrCentral::SphereShapeComponentRequests::GetRadius);
        m_shapeConfigs.emplace_back(AZStd::make_shared<Physics::SphereShapeConfiguration>(radius));
    }

    void ShapeConfigUpdateContext::UpdatePolygonPrismDecomposition()
    {
        AZ::PolygonPrismPtr polygonPrismPtr;
        LmbrCentral::PolygonPrismShapeComponentRequestBus::EventResult(polygonPrismPtr, GetEntityId(),
            &LmbrCentral::PolygonPrismShapeComponentRequests::GetPolygonPrism);

        if (polygonPrismPtr)
        {
            m_mesh.Clear();

            UpdatePolygonPrismDecomposition(polygonPrismPtr);

            m_mesh.SetDebugDrawDirty();
        }
    }


    void ShapeConfigUpdateContext::UpdateCylinderConfig()
    {
        LmbrCentral::CylinderShapeConfig cylinder;
        LmbrCentral::CylinderShapeComponentRequestsBus::EventResult(cylinder, GetEntityId(),
            &LmbrCentral::CylinderShapeComponentRequests::GetCylinderConfiguration);

        // TODO: make parameters configurable
        // The standard width of a single strip of the cylinder wall; number of strips is based on radius and this constant
        static const float CylinderStripSize = 0.05;
        static const size_t MinimumNumberOfStrips = 12;

        // Derived parameters
        const float circumference = cylinder.m_radius * AZ::Constants::TwoPi;
        const size_t nStrips = AZ::GetMax(MinimumNumberOfStrips, (size_t)::ceilf(circumference / CylinderStripSize));
        const float angleDelta = AZ::Constants::TwoPi / nStrips;
        AZ_Assert(nStrips > 0, AZ_FUNCTION_SIGNATURE " - invalid topologization, number of strips is zero");

        const auto PositionForAngle = [&](float angle) {
            AZ::VectorFloat sin, cos;
            AZ::GetSinCos(AZ::VectorFloat(angle), sin, cos);
            return cylinder.m_radius * AZ::Vector2(cos, sin);
        };

        // Iterate over strips to build the total vertex set
        AZStd::vector<AZ::Vector3> verts;
        for (size_t stripIx = 0; stripIx < nStrips; ++stripIx)
        {
            const float angle = angleDelta * stripIx;
            const AZ::Vector2 pos = PositionForAngle(angle);

            verts.push_back(AZ::Vector2ToVector3(pos, -0.5f * cylinder.m_height));
            verts.push_back(AZ::Vector2ToVector3(pos,  0.5f * cylinder.m_height));
        }

        // PhysX convex meshes are limited to 256 vertices
        // Split meshes into approximately equal groups of this many vertices
        static const size_t VertexLimit = 256;
        const size_t totalVertices = verts.size();
        const size_t nMeshes = (size_t)::ceilf((float)totalVertices / (float)VertexLimit);
        if (nMeshes == 1)
        {
            // If there is only one mesh, just create it directly
            AddMeshShape(verts);
        }
        else
        {
            const size_t groupSize = (size_t)::ceilf((float)totalVertices / (float)nMeshes);

            AZStd::vector<AZ::Vector3> insidePiece;

            // This handles outer sections of the cylinder,
            // i.e. protrustion of arcs of the circle faces
            // i.e. sections cut from the cylinder which are parallel to the cylinder axis
            for (size_t startVertex = 0; startVertex < totalVertices; startVertex += groupSize)
            {
                const size_t endVertex = AZ::GetMin(startVertex + groupSize, totalVertices);
                const size_t nVertices = endVertex - startVertex;
                AZ_Assert(startVertex + nVertices <= totalVertices, AZ_FUNCTION_SIGNATURE " - bad vertex index");

                // Add mesh shape
                AddMeshShape(&verts[startVertex], nVertices);

                // Add the first and last edge of the cylinder
                insidePiece.push_back(verts[startVertex]);
                insidePiece.push_back(verts[startVertex+1]);
                insidePiece.push_back(verts[startVertex+nVertices-1]);
                insidePiece.push_back(verts[startVertex+nVertices-2]);
            }

            // This handles the regular polygonal prism (for which the number of sides is nMeshes)
            AddMeshShape(insidePiece);
        }
    }

    void ShapeConfigUpdateContext::UpdatePolygonPrismDecomposition(const AZ::PolygonPrismPtr polygonPrismPtr)
    {
        const AZStd::vector<AZ::Vector2>& vertices = polygonPrismPtr->m_vertexContainer.GetVertices();

        // if the polygon prism vertices do not form a simple polygon, we cannot perform the decomposition
        if (!AZ::Geometry2DUtils::IsSimplePolygon(vertices))
        {
            if (!m_state.m_simplePolygonErrorIssued)
            {
                AZ_Error("PhysX Shape Collider Component", false, "Invalid polygon prism for entity \"%s\""
                    " - must be a simple polygon (no self intersection or duplicate vertices) to be represented in PhysX.",
                    GetEntity()->GetName().c_str());
                m_state.m_simplePolygonErrorIssued = true;
            }

            m_mesh.Clear();
            m_shapeConfigs.clear();
            return;
        }

        m_state.m_simplePolygonErrorIssued = false;
        size_t numFacesRemoved = 0;

        // If the polygon prism is already convex and meets the PhysX limit on convex mesh vertices/faces,
        // then we don't need to do any complicated decomposition
        if (vertices.size() <= PolygonPrismMeshUtils::MaxPolygonPrismEdges && AZ::Geometry2DUtils::IsConvex(vertices))
        {
            m_mesh.CreateFromSimpleConvexPolygon(vertices);
        }
        else
        {
            // Compute the constrained Delaunay triangulation using poly2tri
            AZStd::vector<p2t::Point> p2tVertices;
            std::vector<p2t::Point*> polyline;
            p2tVertices.reserve(vertices.size());
            polyline.reserve(vertices.size());

            int vertexIndex = 0;
            for (const AZ::Vector2& vert : vertices)
            {
                p2tVertices.push_back(p2t::Point(vert.GetX(), vert.GetY()));
                polyline.push_back(&(p2tVertices.data()[vertexIndex++]));
            }

            p2t::CDT constrainedDelaunayTriangulation(polyline);
            constrainedDelaunayTriangulation.Triangulate();
            const std::vector<p2t::Triangle*>& triangles = constrainedDelaunayTriangulation.GetTriangles();

            // Iteratively merge faces if it's possible to do so while maintaining convexity
            m_mesh.CreateFromPoly2Tri(triangles);
            numFacesRemoved = m_mesh.ConvexMerge();
        }

        // Create the cooked convex mesh configurations
        const AZStd::vector<PolygonPrismMeshUtils::Face>& faces = m_mesh.GetFaces();
        size_t numFacesTotal = faces.size();
        m_shapeConfigs.clear();
        if (numFacesRemoved <= numFacesTotal)
        {
            m_shapeConfigs.reserve(numFacesTotal - numFacesRemoved);
        }
        const float height = polygonPrismPtr->GetHeight();

        for (int faceIndex = 0; faceIndex < numFacesTotal; faceIndex++)
        {
            if (faces[faceIndex].m_removed)
            {
                continue;
            }

            AZStd::vector<AZ::Vector3> points;
            points.reserve(2 * faces[faceIndex].m_numEdges);
            PolygonPrismMeshUtils::HalfEdge* currentEdge = faces[faceIndex].m_edge;

            for (int edgeIndex = 0; edgeIndex < faces[faceIndex].m_numEdges; edgeIndex++)
            {
                points.emplace_back(AZ::Vector3(currentEdge->m_origin.GetX(), currentEdge->m_origin.GetY(), 0.0f));
                points.emplace_back(AZ::Vector3(currentEdge->m_origin.GetX(), currentEdge->m_origin.GetY(), height));
                currentEdge = currentEdge->m_next;
            }

            AddMeshShape(points);
        }
    }

    void ShapeConfigUpdateContext::AddMeshShape(const AZ::Vector3* pPoints, size_t nPoints)
    {
        AZStd::vector<AZ::u8> cookedData;
        bool cookingResult = false;
        PhysX::SystemRequestsBus::BroadcastResult(cookingResult, &PhysX::SystemRequests::CookConvexMeshToMemory,
            pPoints, static_cast<AZ::u32>(nPoints), cookedData);
        if (!cookingResult)
        {
            AZ_Warning("ShapeConfigUpdateContext", false, "Mesh cooking failed for %s; this shape will be ignored",
                GetEntity()->GetName().c_str()
            );
            return;
        }

        Physics::CookedMeshShapeConfiguration shapeConfig;
        shapeConfig.SetCookedMeshData(cookedData.data(), cookedData.size(), Physics::CookedMeshShapeConfiguration::MeshType::Convex);

        m_shapeConfigs.push_back(AZStd::make_shared<Physics::CookedMeshShapeConfiguration>(shapeConfig));
    }

    void ShapeConfigUpdateContext::AddMeshShape(const AZStd::vector<AZ::Vector3>& points)
    {
        AddMeshShape(points.data(), points.size());
    }

    void DynamicShapeColliderComponent::Reflect(AZ::ReflectContext * context)
    {
        if (auto serializeContext = azrtti_cast<AZ::SerializeContext*>(context))
        {
            serializeContext->Class<DynamicShapeColliderComponent, ShapeColliderComponent>()
                ->Version(1)
                ;
        }
    }

    DynamicShapeColliderComponent::DynamicShapeColliderComponent(const Physics::ColliderConfiguration& cfg)
        : m_colliderConfig(cfg)
    {
    }

    void DynamicShapeColliderComponent::UpdateScaleForShapeConfigs()
    {
        // Build the shape config
        DynamicShapeColliderBase builder;
        ShapeConfigs shapeConfigs;
        PolygonPrismMeshUtils::Mesh2D polygonPrismMesh;
        builder.UpdateShapeConfigs(shapeConfigs, polygonPrismMesh, GetEntity());

        // Copy collider config to each shape config
        Physics::ShapeConfigurationList shapeConfigurationList;
        shapeConfigurationList.reserve(shapeConfigs.size());
        for (const auto& shapeConfig : shapeConfigs)
        {
            shapeConfigurationList.emplace_back(
                AZStd::make_shared<Physics::ColliderConfiguration>(m_colliderConfig),
                shapeConfig);
        }

        // Set config
        SetShapeConfigurationList(shapeConfigurationList);

        // Call base class update function
        ShapeColliderComponent::UpdateScaleForShapeConfigs();
    }
}